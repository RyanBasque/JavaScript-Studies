### JavaScript üëã

- JavaScript √© uma linguagem de programa√ß√£o n√£o compilada, ou seja, n√£o necessita de um compilador para rodar (ex: Java e seu sdk).
- JavaScript tem uma tipagem fraca, ou seja, voc√™ pode aplicar v√°rios tipos de dados √† mesma vari√°vel.
- √â uma linguagem de multiparadigma, ou seja, n√£o h√° necessidade de seguir um padr√£o, como POO (programa√ß√£o orientada a objetos).
- Principal uso: Client-side (browser), mas tamb√©m com Server-side (NodeJS).

### Babel

- Apesar do JavaScript ser uma linguagem n√£o interpretada, nas novas updates (ES5+) se tornou necess√°rio o uso de um compilador (para que todoso os sites na web n√£o quebrem com uma mudan√ßa direta na fonte do JavaScript), que no caso, √© o BabelJs.
- O Babel transforma let em var, arrow functions em functions, etc. Vejas as compatibilidades aqui https://github.com/kangax/compat-table;

### Ferramentas necess√°rias

- Browser evergreen (que est√° 100% atualizada com a linguagem);
- Git e GitHub;
- VsCode ou outros;
- NodeJs;

### Testes de JavaScript

Existem v√°rias formas de testar um arquivo JavaScript, citarei duas:

- No console Node usando o comando: node caminho-do-arquivo (use tab para ver quais arquivos h√£o);
- Usando o comando node no terminal e logo em seguida colocando o c√≥digo para testar (control + c para sair);
- Usando o console (F12) do browser;
- No browser em uma p√°gina HTML dentro da tag <script></script>, sendo uma tag normal ou uma orf√£ com caminho especificado para o arquuvo JavaScript <script src="./variaveis.js">.

Algumas dicas e coisas a se fazer:

- N√£o colocar o script dentro do head (motivo: performance);
- Colocar o script orf√£o dentro do body, mas no fim (motivo: performance);
- Code plugin: Code Runner, deixa dispon√≠vel um bot√£o de "run" no canto superior direito, executando um arquivo (simula√ß√£o do node caminho-do-arquivo, mas no arquivo que voc√™ est√° visualizando).

Teorias:

- Alguns c√≥digos s√≥ funcionam no browser (na DOM), como por exemplo, o alert(`Ol√°, mundo! üëã`). Esse c√≥digo n√£o funciona no terminal node por raz√µes √≥bvias (o terminal n√£o pode exibir uma alerta). A mensagem de erro √©: Uncaught ReferenceError: alert is not defined;
- DOM: Document Object Model;

### Vari√°veis

- Podem ser criadas usando var, let ou const;
- Var √© do ES5, funciona em diversos browsers;
- Let e const vieram a partir do ES2015, mas n√£o funcionam em 100% dos browsers;
- √â poss√≠vel redeclarar o valor da vari√°vel infinitas vezes sem se preocupar com o tipo de dado (JavaScript n√£o √© uma linguagem tipada);
- N√£o √© poss√≠vel declarar duas vari√°veis com o mesmo nome `Com excess√£o se elas forem criadas com o uso de var` (por esse otivo e outros o uso de var vem sido desconsiderado);
- Let e var significam a mesma coisa (com excess√£o do erro citado acima), mas o const significa uma vari√°vel (constante) que n√£o pode ter seu valor alterado (caso tente alterar seu valor, o JavaScrit apresentar√° o seguinte erro: TypeError: Assignment to constant variable);
- O JavaScript n√£o aceita hifens na declara√ß√£o de nomes de vari√°veis;
- O JavaScript tamb√©m n√£o aceita iniciar o nome com n√∫mero, mas aceita se o n√∫mero vier em segundo caractere para frente;
- O JavaScript tamb√©m n√£o aceita caracteres especiais, salvo \_ e $;

### Tipos de dados primitivos

- Os tipos primitivos s√£o: Number (int e float), String e Boolean;
- Number int: n√∫meros inteiros;
- Number float: `pontos flutuantes` ou n√∫meros decimais;
- Typeof nome-da-vari√°vel para identificar o tipo de dado;

### Vari√°veis - String

- Vari√°veis tipo string s√£o identificadas pelo uso de aspas;
- Em JavaScript o uso de aspas simples ou duplas n√£o faz diferen√ßa alguma;
- Tamb√©m h√° o uso de template literals, fazendo o uso de crase (ex: let nome = `Ryan`);
- √â poss√≠vel usar aspas simples dentro de aspas duplas e vice versa, mas nunca o mesmo tipo de aspas dentro do valor (ex: let teste = "vari√°vel com "aspas"" // erro; let testeDois = "vari√°vel com 'aspas'");
- A solu√ß√£o do problema de cima √© dizer para o JavaScript que aquilo √© literal com o uso de barras (ex: let teste = " meu nome √© \"Ryan\" ");
- √â poss√≠vel colocar o valor de uma var√≠avel dentro de uma string e concatenar strings com o template literals (\* apenas no ES2015+ ex: let teste = `String com valor ${nome-da-variavel}`);

### Vari√°veis - Number

- Dois tipos: Int (inteiro) e Float (flutuante, decimal);

### Vari√°veis - Boolean

- Ou √© true ou false;

### Vari√°veis - Undefined, Null e Symbol (ES2015)

- Undefined signifca que a v√°riavel foi declarada, mas n√£o teve valor atribu√≠do;
- Usar typeof ou console.log pode verificar se h√° algum valor;
- Uma vari√°vel com valor `null` tem como tipo o {object}. Isso √© um erro de implementa√ß√£o do JavaScript, mas para n√£o quebrar c√≥digo antigo, este erro n√£o foi resolvido.

### Vari√°veis - Convers√£o entre tipos

- O JavaScript √© inteligente o suficiente para fazer uma convers√£o impl√≠cita, ou seja, ele sabe que n√£o √© poss√≠vel multiplicar um n√∫mero por uma string, ent√£o ele verifica se √© poss√≠vel fazer uma convers√£o de string para n√∫mero, e se poss√≠vel, faz a multiplica√ß√£o;
- O item acima pode ser um problema na hora de somar n√∫meros com strings, porque ele n√£o vai somar, e sim concatenar;
- No item acima, o JavaScript transforma os 2 em string (por baixo dos panos) obs: o JavaScript apenas faz isso na hora de somar;
- Toda informa√ß√£o que vem na interface gr√°fica do JavaScript vem como string, mesmo que voc√™ coloque, por exemplo, um <input type="number">;

### Convers√£o entre tipos - parseInt() e parseFloat()

- let n1 = "10.89723". Usando o parseInt(n1), ele faz virar n√∫mero ignorando completamente os n√∫meros ap√≥s a v√≠rgula, deixando apenas como 10.
- J√° o parseFloat(n1) transformaria em um n√∫mero quebrado, exatamente como era quando string, ou seja: 10.89723.
- O float considera n√∫meros decimais apenas os que tem (.), ou seja ignoraria e deixaria apenas se fosse: 10,89723.
- O parseInt ignora as letras e n√∫meros que vem ap√≥s os n√∫meros (ex: 10ads1232, sa√≠da: 10);
- O parseInt retorna NaN se o primeiro caractere for uma string;
- O construtor Number() retorna NaN se houver qualquer letra dentro da string, ou seja, aceita apenas n√∫meros;

### Convers√£o entre tipos - Number para String

- Alguns jeitos de converter:
- let teste = 10; teste = teste + "";
- teste.toString();
- decimais: 0 - 9, hexadecimais: 0 - f(15), bin√°rio: 0 e 1;
- O toString pode receber um parametro opcional para especificar a base de convers√£o (decimal, hexadecimal, bin√°rio, etc);

### Operadores aritim√©ticos

- Os operadores aritim√©ticos s√£o: +, -, \*, /, %, \*\*;
- Resto de divis√£o: % (muito utilizado para recuperar n√∫meros m√∫ltiplos de 3, etc);
- Pot√™ncia: ** (n√£o funciona em todos os browsers, ex: 2 ** 3);
- O sinal de / tem prefer√™ncia, para mudar use ( );

### Operadores de atribui√ß√£o

- Todos os operadores aritim√©ticos est√£o dentro dos operadores de atribui√ß√£o;
- Operador mais usado: = (serve para atribuir valor a uma vari√°vel);
- Os outros operadores servem para o √∫ltimo valor da vari√°vel e atribuir com uma opera√ß√£o;
- Exemplo: atribuicaoDeValor += 7; (soma o √∫ltimo valor da vari√°vel com o 7);
- Os outros operadores s√£o: =-, =/, =\*, =%, =\*\* (s√£o dificilmente usados);

### Operadores de incremento e decremento

- Usados para somar ou diminuir 1;
- Exemplo de uso: let i = 0; i++ (p√≥s-incremento);
- Exemplo de uso: let i = 0; ++i (pr√©-incremento);
- Exemplo de uso: let i = 1; i-- (p√≥s-decremento);
- Exemplo de uso: let i = 1; --i (pr√©-decremento);
- Diferen√ßa entre pr√© e p√≥s:
- Quanto a otimiza√ß√£o, o p√≥s-incremento faz uso de uma vari√°vel tempor√°ria para armazenar o valor de i antes do incremento, j√° o pr√©-incremento adiciona o valor a vari√°vel original, no entanto isto √© uma otimiza√ß√£o prematura e √© estatisticamente insignificante.

### Operadores de compara√ß√£o

- Igualdade de valor: ==;
- Igualdade de valor e tipo ===;
- Diferen√ßa de valor !=;
- Diferen√ßa de valor e tipo !==;
- Menor que: <;
- Maior que: >;
- Menor ou igual que: <=;
- Maior ou igual que: >=;
- console.log(10 > 2), retorna true;

### Operadores l√≥gicos

- Tr√™s tipos: and (&&), or (||) e not (!);

### Preced√™ncia de operadores

- O operador && tem prefer√™ncia, ou seja, √© executado primeiro (ex: (idade >= 18 || paisPresentes) && comprouBilhete);
- A ordem do primeiro item pode ser mudada se for usado o operador ( ), ent√£o o c√≥digo dentro dos par√™nteses ser√° executado primeiro;
- Resposta do primeiro item: true, false

### If e Else

- if(express√£o com retorno true) { c√≥digo } else { c√≥digo };
- if(!condi√ß√£o) verifica se a condi√ß√£o √© falsa, se sim, ent√£o o if √© executado;
- Tamb√©m h√° o else if(condi√ß√£o) {}

### If e Else tern√°rio

- Um jeito de fazer um if para c√≥digos menores;
- `let changedIf = teste === 0 ? 'retorno true' : 'retorno false' `;

### Valores falsy e truthy

- Valores considerados true ou false quando h√° uma condi√ß√£o (ex: if e else);
- Dentro de estruturas condicionais alguns valores s√£o avaliados como true ou false, por exemplo:
- Falsy (0, '', NaN, undefined, null, false); // obs: apenas '' e n√£o ' '
- Todos os demais s√£o considerados true;
- `0 ? console.log('true') : console.log('0 is false')` // '0 is false';

### Curto-circuito

- Usar os operadores l√≥gico para executar express√µes de forma mais elegante;
- O exemplo mais pr√°tico de curto-circuito √© com o operador &&. Este operador verifica se a condi√ß√£o √© true, se for ele vai para pr√≥xima condi√ß√£o que √© uma fun√ß√£o (ex: isValid && console.log('√â v√°lido'));
- Agora se for um operador Or(||), o JavaScript verifica se a primeiro condi√ß√£o √© true, se n√£o for ele olha a pr√≥xima condi√ß√£o que √© uma fun√ß√£o (ex: isValid || console.log('N√£o √© v√°lido')), mas se a primeira condi√ß√£o for true, ele deixa de observar a pr√≥xima e simplesmente n√£o excuta nada;
- Valores falsy e truthy s√£o observados tamb√©m;

### Condicional Switch

- Um jeito de criar um if sem repet√≠-lo v√°rias vezes;
- Switch(vari√°vel) { case compara√ß√£o: comando; break; variavel === 'teste': comando; break; default: comando };
- O case faz refer√™ncia a compara√ß√£o da vari√°vel (igual ao parametro do if), o comando √© o c√≥digo que ele vai rodar e o break √© o que define se o switch vai parar de ser executado quando aquele case for verdadeiro;
- O default √© quase um else, caso nenhum case seja verdadeiro, o default ser√° aplicado;

### La√ßos de repeti√ß√£o

- Ajuda a quebrar esfor√ßos repetitivos;
- While(repete o la√ßo at√© que a condi√ß√£o seja false) { c√≥digo } (obs: por favor, garanta que a condi√ß√£o vire false);
- Let indice = 0; while(indice < 10) { i++; console.log(indice) };
- For(let i = 0; j < 10; j++) { c√≥digo };
- O for recebe 3 express√µes, uma vari√°vel (voc√™ pode criar uma usando let ou var), a condi√ß√£o de repeti√ß√£o e um operador de incremento ou decremento da primeira express√£o (vari√°vel);
- O do { c√≥digo } while() {} faz com que a a√ß√£o dentro do Do seja executada pelo menos uma vez;

### Continue vs break

- Palavras que mudam o flow de um loop;
- Break, continue e return;
- O break faz com que o for, while e o switch (podem haver mais) parem de executar x c√≥digo;
- O continue faz com que o um c√≥digo seja ignorado caso a condi√ß√£o seja verdadeira (tome cuidado ao usar no while, garanta que o incrementador seja executado);

### Break vs Return

- O return para de executar a fun√ß√£o, enquanto break a executa uma √∫ltima vez antes de terminar;
- O return para e fun√ß√£o e pode retornar algo ao mesmo tempo;

### Fun√ß√µes

- Existem v√°rias maneiras de se criar uma fun√ß√£o, dentre elas est√£o as com declara√ß√£o fun√ß√£o, funcions expressions (com vari√°veis) e as arrow functions;
- function teste() { console.log('declara√ß√£o de fun√ß√£o') };
- const teste = function () { console.log('function express') };
- const teste = () => { console.log('arrows functions') }; // existe desde o ES2015

### Fun√ß√µes com retorno de valores

- Retornar valores (ex: retorna o dia da semana)
- function teste() { return 6 };
- let testeVar = teste();
- console.log(testeVar) // mostra 6;

### Fun√ß√µes que recebem param√™tros

- Fun√ß√µes que recebem valores dentro de suas chaves, podendo ser opcionais ou n√£o, usando function teste(n1, n2 = null);

### Escopo de vari√°veis

- Escopo de bloco: vari√°vel ou fun√ß√£o criadas dentro de outra fun√ß√£o s√≥ tem o alcance de bloco, ou seja, apenas naquela fun√ß√£o;
- Podem ser criadas vari√°veis de bloco com mesmo nome das globais;
- Fun√ß√µes criadas dentro de outras fun√ß√µes s√≥ tem escopo de bloco;

### Arrays
